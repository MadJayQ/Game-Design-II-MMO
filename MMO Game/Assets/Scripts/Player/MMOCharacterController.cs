using System.Collections;
using System.Collections.Generic;
using UnityEngine;

using KinematicCharacterController;

[System.Serializable]
public struct UserCMD {
	public float ForwardMove;
	public float RightMove;
	public float UpMove;
	public Quaternion Rotation;
}

public class MMOCharacterController : BaseCharacterController {

	[Header("Ground Movement")]
	public float RotationSharpness = 15f;
	public float MovementSpeed = 5f;
	public float AccelerationFactor = 3f;
	[Header("Air Movement")]
	public float MaxAirFactor = 1.3f;
	public float AirAcceleration = 1.1f;
	[Header("Physics")]
	public Vector3 Gravity = new Vector3(0, -10f, 0);
	public bool HasGravity = true;
	public bool OrientGravity = true;
	public bool HasDrag = false;
	public float DragCoefficient = 0.134f;

	private Vector3 m_MovementInputVector = Vector3.zero;

	private Quaternion m_Rotation = Quaternion.identity;

	public void RunCommand(ref UserCMD cmd) {
		cmd.UpMove = 0f;
		Vector3 moveInputVector3 = Vector3.ClampMagnitude(new Vector3(
			cmd.RightMove,
			cmd.UpMove,
			cmd.ForwardMove
		), 1f);

		m_Rotation = cmd.Rotation;

		Vector3 planarDirection = Vector3.ProjectOnPlane(
			cmd.Rotation * Vector3.forward, 
			Motor.CharacterUp
		).normalized;
		if(planarDirection.sqrMagnitude == 0f) {
			planarDirection = Vector3.ProjectOnPlane(
				cmd.Rotation * Vector3.up,
				Motor.CharacterUp
			).normalized;
		}

		Quaternion planarRotation = Quaternion.LookRotation(
			planarDirection,
			Motor.CharacterUp
		);

		m_MovementInputVector = planarRotation * moveInputVector3;
	}

	public override void BeforeCharacterUpdate(float deltaTime) {

	}

	public override void UpdateRotation(ref Quaternion currentRotation, float deltaTime) {
		currentRotation = Quaternion.Slerp(currentRotation, m_Rotation,  1f - Mathf.Exp(-RotationSharpness * deltaTime));
		if(OrientGravity) {
			currentRotation = Quaternion.FromToRotation((currentRotation * Vector3.up), -Gravity) * currentRotation;
		}
	}

	public override void UpdateVelocity(ref Vector3 currentVelocity, float deltaTime) {
		Vector3 targetMovementVelocity = Vector3.zero;
		if(Motor.GroundingStatus.IsStableOnGround) {
			Vector3 effectiveGroundNormal = Motor.GroundingStatus.GroundNormal;
			if(currentVelocity.sqrMagnitude > 0f && Motor.GroundingStatus.SnappingPrevented) {
				Vector3 groundPointToCharacter = Motor.TransientPosition - Motor.GroundingStatus.GroundPoint;
				if(Vector3.Dot(currentVelocity, groundPointToCharacter) >= 0f) {
					effectiveGroundNormal = Motor.GroundingStatus.OuterGroundNormal;
				} else {
					effectiveGroundNormal = Motor.GroundingStatus.InnerGroundNormal;
				}
			}

			currentVelocity = Motor.GetDirectionTangentToSurface(
				currentVelocity,
				effectiveGroundNormal
			) * currentVelocity.magnitude;

			//We're going to project our movement onto the plane generated by the EGN 
			Vector3 inputRight = Vector3.Cross(m_MovementInputVector, Motor.CharacterUp);
			Vector3 reorientedInput = Vector3.Cross(
				effectiveGroundNormal,
				inputRight
			).normalized;

			targetMovementVelocity = reorientedInput * MovementSpeed;
			currentVelocity = Vector3.Lerp(currentVelocity, targetMovementVelocity, 1 - Mathf.Exp(-AccelerationFactor * deltaTime)); 
		} else {
			if(m_MovementInputVector.sqrMagnitude > 0f) {
				targetMovementVelocity = m_MovementInputVector * MaxAirFactor;

				if(Motor.GroundingStatus.FoundAnyGround) {
					Vector3 obsNormal = Vector3.Cross(
						Vector3.Cross(Motor.CharacterUp, Motor.GroundingStatus.GroundNormal),
						Motor.CharacterUp
					).normalized;
					targetMovementVelocity = Vector3.ProjectOnPlane(targetMovementVelocity, obsNormal);
				}

				Vector3 deltaVelocity = Vector3.ProjectOnPlane(
					targetMovementVelocity - currentVelocity,
					Gravity
				);
				currentVelocity += deltaVelocity * AirAcceleration * deltaTime;
			}
			currentVelocity += Gravity * deltaTime;

			if(HasDrag) {
				currentVelocity *= Mathf.Pow(1f + (DragCoefficient * deltaTime), -1);
			}
		}
	}

	public override void AfterCharacterUpdate(float deltaTime) {

	}

	public override void PostGroundingUpdate(float deltaTime) {

	}

	public override bool IsColliderValidForCollisions(Collider coll) {
		return true;
	}

	public override void OnGroundHit(Collider hitCollider, Vector3 hitNormal, Vector3 hitPoint, ref HitStabilityReport hitStabilityReport) {

	}

	public override void OnMovementHit(Collider hitCollider, Vector3 hitNormal, Vector3 hitPoint, ref HitStabilityReport hitStabilityReport) {

	}

	public override void ProcessHitStabilityReport(Collider hitCollider, Vector3 hitNormal, Vector3 hitPoint, Vector3 atCharacterPosition, Quaternion atCharacterRotation, ref HitStabilityReport hitStabilityReport) {

	}
}
